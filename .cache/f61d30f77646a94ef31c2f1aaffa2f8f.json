{"dependencies":[{"name":"tslib","loc":{"line":1,"column":39}},{"name":"@tensorflow/tfjs-core","loc":{"line":2,"column":20}},{"name":"../classes","loc":{"line":3,"column":22}},{"name":"../ops","loc":{"line":4,"column":34}},{"name":"./extractImagePatches","loc":{"line":5,"column":36}},{"name":"./MtcnnBox","loc":{"line":6,"column":25}},{"name":"./ONet","loc":{"line":7,"column":21}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stage3 = stage3;\n\nvar _tslib = require(\"tslib\");\n\nvar _tfjsCore = require(\"@tensorflow/tfjs-core\");\n\nvar tf = _interopRequireWildcard(_tfjsCore);\n\nvar _classes = require(\"../classes\");\n\nvar _ops = require(\"../ops\");\n\nvar _extractImagePatches = require(\"./extractImagePatches\");\n\nvar _MtcnnBox = require(\"./MtcnnBox\");\n\nvar _ONet = require(\"./ONet\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction stage3(img, inputBoxes, scoreThreshold, params, stats) {\n  return (0, _tslib.__awaiter)(this, void 0, void 0, function () {\n    var ts, onetInputs, onetOuts, scoresTensor, scores, _a, _b, indices, filteredRegions, filteredBoxes, filteredScores, finalBoxes, finalScores, points, indicesNms;\n    return (0, _tslib.__generator)(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          ts = Date.now();\n          return [4 /*yield*/, (0, _extractImagePatches.extractImagePatches)(img, inputBoxes, { width: 48, height: 48 })];\n        case 1:\n          onetInputs = _c.sent();\n          stats.stage3_extractImagePatches = Date.now() - ts;\n          ts = Date.now();\n          onetOuts = onetInputs.map(function (onetInput) {\n            var out = (0, _ONet.ONet)(onetInput, params);\n            onetInput.dispose();\n            return out;\n          });\n          stats.stage3_onet = Date.now() - ts;\n          scoresTensor = onetOuts.length > 1 ? tf.concat(onetOuts.map(function (out) {\n            return out.scores;\n          })) : onetOuts[0].scores;\n          _b = (_a = Array).from;\n          return [4 /*yield*/, scoresTensor.data()];\n        case 2:\n          scores = _b.apply(_a, [_c.sent()]);\n          scoresTensor.dispose();\n          indices = scores.map(function (score, idx) {\n            return { score: score, idx: idx };\n          }).filter(function (c) {\n            return c.score > scoreThreshold;\n          }).map(function (_a) {\n            var idx = _a.idx;\n            return idx;\n          });\n          filteredRegions = indices.map(function (idx) {\n            var regionsData = onetOuts[idx].regions.arraySync();\n            return new _MtcnnBox.MtcnnBox(regionsData[0][0], regionsData[0][1], regionsData[0][2], regionsData[0][3]);\n          });\n          filteredBoxes = indices.map(function (idx, i) {\n            return inputBoxes[idx].calibrate(filteredRegions[i]);\n          });\n          filteredScores = indices.map(function (idx) {\n            return scores[idx];\n          });\n          finalBoxes = [];\n          finalScores = [];\n          points = [];\n          if (filteredBoxes.length > 0) {\n            ts = Date.now();\n            indicesNms = (0, _ops.nonMaxSuppression)(filteredBoxes, filteredScores, 0.7, false);\n            stats.stage3_nms = Date.now() - ts;\n            finalBoxes = indicesNms.map(function (idx) {\n              return filteredBoxes[idx];\n            });\n            finalScores = indicesNms.map(function (idx) {\n              return filteredScores[idx];\n            });\n            points = indicesNms.map(function (idx, i) {\n              return Array(5).fill(0).map(function (_, ptIdx) {\n                var pointsData = onetOuts[idx].points.arraySync();\n                return new _classes.Point(pointsData[0][ptIdx] * (finalBoxes[i].width + 1) + finalBoxes[i].left, pointsData[0][ptIdx + 5] * (finalBoxes[i].height + 1) + finalBoxes[i].top);\n              });\n            });\n          }\n          onetOuts.forEach(function (t) {\n            t.regions.dispose();\n            t.scores.dispose();\n            t.points.dispose();\n          });\n          return [2 /*return*/, {\n            boxes: finalBoxes,\n            scores: finalScores,\n            points: points\n          }];\n      }\n    });\n  });\n}\n//# sourceMappingURL=stage3.js.map"},"hash":"2ded2eef1b9352520af0de66189511ef"}
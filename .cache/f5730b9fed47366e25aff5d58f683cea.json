{"dependencies":[{"name":"tslib","loc":{"line":1,"column":60}},{"name":"@tensorflow/tfjs-core","loc":{"line":2,"column":20}},{"name":"../classes/BoundingBox","loc":{"line":3,"column":28}},{"name":"../classes/ObjectDetection","loc":{"line":4,"column":32}},{"name":"../common","loc":{"line":5,"column":26}},{"name":"../dom","loc":{"line":6,"column":27}},{"name":"../NeuralNetwork","loc":{"line":7,"column":30}},{"name":"../ops","loc":{"line":8,"column":24}},{"name":"../ops/nonMaxSuppression","loc":{"line":9,"column":34}},{"name":"../ops/normalize","loc":{"line":10,"column":26}},{"name":"./config","loc":{"line":11,"column":31}},{"name":"./convWithBatchNorm","loc":{"line":12,"column":34}},{"name":"./depthwiseSeparableConv","loc":{"line":13,"column":39}},{"name":"./extractParams","loc":{"line":14,"column":30}},{"name":"./extractParamsFromWeigthMap","loc":{"line":15,"column":43}},{"name":"./leaky","loc":{"line":16,"column":22}},{"name":"./TinyYolov2Options","loc":{"line":17,"column":34}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TinyYolov2Base = undefined;\n\nvar _tslib = require(\"tslib\");\n\nvar _tfjsCore = require(\"@tensorflow/tfjs-core\");\n\nvar tf = _interopRequireWildcard(_tfjsCore);\n\nvar _BoundingBox = require(\"../classes/BoundingBox\");\n\nvar _ObjectDetection = require(\"../classes/ObjectDetection\");\n\nvar _common = require(\"../common\");\n\nvar _dom = require(\"../dom\");\n\nvar _NeuralNetwork = require(\"../NeuralNetwork\");\n\nvar _ops = require(\"../ops\");\n\nvar _nonMaxSuppression = require(\"../ops/nonMaxSuppression\");\n\nvar _normalize = require(\"../ops/normalize\");\n\nvar _config = require(\"./config\");\n\nvar _convWithBatchNorm = require(\"./convWithBatchNorm\");\n\nvar _depthwiseSeparableConv = require(\"./depthwiseSeparableConv\");\n\nvar _extractParams = require(\"./extractParams\");\n\nvar _extractParamsFromWeigthMap = require(\"./extractParamsFromWeigthMap\");\n\nvar _leaky = require(\"./leaky\");\n\nvar _TinyYolov2Options = require(\"./TinyYolov2Options\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar TinyYolov2Base = /** @class */function (_super) {\n  (0, _tslib.__extends)(TinyYolov2Base, _super);\n  function TinyYolov2Base(config) {\n    var _this = _super.call(this, 'TinyYolov2') || this;\n    (0, _config.validateConfig)(config);\n    _this._config = config;\n    return _this;\n  }\n  Object.defineProperty(TinyYolov2Base.prototype, \"config\", {\n    get: function () {\n      return this._config;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TinyYolov2Base.prototype, \"withClassScores\", {\n    get: function () {\n      return this.config.withClassScores || this.config.classes.length > 1;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TinyYolov2Base.prototype, \"boxEncodingSize\", {\n    get: function () {\n      return 5 + (this.withClassScores ? this.config.classes.length : 0);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  TinyYolov2Base.prototype.runTinyYolov2 = function (x, params) {\n    var out = (0, _convWithBatchNorm.convWithBatchNorm)(x, params.conv0);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = (0, _convWithBatchNorm.convWithBatchNorm)(out, params.conv1);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = (0, _convWithBatchNorm.convWithBatchNorm)(out, params.conv2);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = (0, _convWithBatchNorm.convWithBatchNorm)(out, params.conv3);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = (0, _convWithBatchNorm.convWithBatchNorm)(out, params.conv4);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = (0, _convWithBatchNorm.convWithBatchNorm)(out, params.conv5);\n    out = tf.maxPool(out, [2, 2], [1, 1], 'same');\n    out = (0, _convWithBatchNorm.convWithBatchNorm)(out, params.conv6);\n    out = (0, _convWithBatchNorm.convWithBatchNorm)(out, params.conv7);\n    return (0, _common.convLayer)(out, params.conv8, 'valid', false);\n  };\n  TinyYolov2Base.prototype.runMobilenet = function (x, params) {\n    var out = this.config.isFirstLayerConv2d ? (0, _leaky.leaky)((0, _common.convLayer)(x, params.conv0, 'valid', false)) : (0, _depthwiseSeparableConv.depthwiseSeparableConv)(x, params.conv0);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = (0, _depthwiseSeparableConv.depthwiseSeparableConv)(out, params.conv1);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = (0, _depthwiseSeparableConv.depthwiseSeparableConv)(out, params.conv2);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = (0, _depthwiseSeparableConv.depthwiseSeparableConv)(out, params.conv3);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = (0, _depthwiseSeparableConv.depthwiseSeparableConv)(out, params.conv4);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = (0, _depthwiseSeparableConv.depthwiseSeparableConv)(out, params.conv5);\n    out = tf.maxPool(out, [2, 2], [1, 1], 'same');\n    out = params.conv6 ? (0, _depthwiseSeparableConv.depthwiseSeparableConv)(out, params.conv6) : out;\n    out = params.conv7 ? (0, _depthwiseSeparableConv.depthwiseSeparableConv)(out, params.conv7) : out;\n    return (0, _common.convLayer)(out, params.conv8, 'valid', false);\n  };\n  TinyYolov2Base.prototype.forwardInput = function (input, inputSize) {\n    var _this = this;\n    var params = this.params;\n    if (!params) {\n      throw new Error('TinyYolov2 - load model before inference');\n    }\n    return tf.tidy(function () {\n      var batchTensor = input.toBatchTensor(inputSize, false).toFloat();\n      batchTensor = _this.config.meanRgb ? (0, _normalize.normalize)(batchTensor, _this.config.meanRgb) : batchTensor;\n      batchTensor = batchTensor.div(tf.scalar(256));\n      return _this.config.withSeparableConvs ? _this.runMobilenet(batchTensor, params) : _this.runTinyYolov2(batchTensor, params);\n    });\n  };\n  TinyYolov2Base.prototype.forward = function (input, inputSize) {\n    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {\n      var _a;\n      return (0, _tslib.__generator)(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = this.forwardInput;\n            return [4 /*yield*/, (0, _dom.toNetInput)(input)];\n          case 1:\n            return [4 /*yield*/, _a.apply(this, [_b.sent(), inputSize])];\n          case 2:\n            return [2 /*return*/, _b.sent()];\n        }\n      });\n    });\n  };\n  TinyYolov2Base.prototype.detect = function (input, forwardParams) {\n    if (forwardParams === void 0) {\n      forwardParams = {};\n    }\n    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {\n      var _a, inputSize, scoreThreshold, netInput, out, out0, inputDimensions, results, boxes, scores, classScores, classNames, indices, detections;\n      var _this = this;\n      return (0, _tslib.__generator)(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = new _TinyYolov2Options.TinyYolov2Options(forwardParams), inputSize = _a.inputSize, scoreThreshold = _a.scoreThreshold;\n            return [4 /*yield*/, (0, _dom.toNetInput)(input)];\n          case 1:\n            netInput = _b.sent();\n            return [4 /*yield*/, this.forwardInput(netInput, inputSize)];\n          case 2:\n            out = _b.sent();\n            out0 = tf.tidy(function () {\n              return tf.unstack(out)[0].expandDims();\n            });\n            inputDimensions = {\n              width: netInput.getInputWidth(0),\n              height: netInput.getInputHeight(0)\n            };\n            return [4 /*yield*/, this.extractBoxes(out0, netInput.getReshapedInputDimensions(0), scoreThreshold)];\n          case 3:\n            results = _b.sent();\n            out.dispose();\n            out0.dispose();\n            boxes = results.map(function (res) {\n              return res.box;\n            });\n            scores = results.map(function (res) {\n              return res.score;\n            });\n            classScores = results.map(function (res) {\n              return res.classScore;\n            });\n            classNames = results.map(function (res) {\n              return _this.config.classes[res.label];\n            });\n            indices = (0, _nonMaxSuppression.nonMaxSuppression)(boxes.map(function (box) {\n              return box.rescale(inputSize);\n            }), scores, this.config.iouThreshold, true);\n            detections = indices.map(function (idx) {\n              return new _ObjectDetection.ObjectDetection(scores[idx], classScores[idx], classNames[idx], boxes[idx], inputDimensions);\n            });\n            return [2 /*return*/, detections];\n        }\n      });\n    });\n  };\n  TinyYolov2Base.prototype.getDefaultModelName = function () {\n    return '';\n  };\n  TinyYolov2Base.prototype.extractParamsFromWeigthMap = function (weightMap) {\n    return (0, _extractParamsFromWeigthMap.extractParamsFromWeigthMap)(weightMap, this.config);\n  };\n  TinyYolov2Base.prototype.extractParams = function (weights) {\n    var filterSizes = this.config.filterSizes || TinyYolov2Base.DEFAULT_FILTER_SIZES;\n    var numFilters = filterSizes ? filterSizes.length : undefined;\n    if (numFilters !== 7 && numFilters !== 8 && numFilters !== 9) {\n      throw new Error(\"TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found \" + numFilters + \" filterSizes in config\");\n    }\n    return (0, _extractParams.extractParams)(weights, this.config, this.boxEncodingSize, filterSizes);\n  };\n  TinyYolov2Base.prototype.extractBoxes = function (outputTensor, inputBlobDimensions, scoreThreshold) {\n    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {\n      var width, height, inputSize, correctionFactorX, correctionFactorY, numCells, numBoxes, _a, boxesTensor, scoresTensor, classScoresTensor, results, scoresData, boxesData, row, col, anchor, score, ctX, ctY, width_1, height_1, x, y, pos, _b, classScore, label, _c;\n      var _this = this;\n      return (0, _tslib.__generator)(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            width = inputBlobDimensions.width, height = inputBlobDimensions.height;\n            inputSize = Math.max(width, height);\n            correctionFactorX = inputSize / width;\n            correctionFactorY = inputSize / height;\n            numCells = outputTensor.shape[1];\n            numBoxes = this.config.anchors.length;\n            _a = tf.tidy(function () {\n              var reshaped = outputTensor.reshape([numCells, numCells, numBoxes, _this.boxEncodingSize]);\n              var boxes = reshaped.slice([0, 0, 0, 0], [numCells, numCells, numBoxes, 4]);\n              var scores = reshaped.slice([0, 0, 0, 4], [numCells, numCells, numBoxes, 1]);\n              var classScores = _this.withClassScores ? tf.softmax(reshaped.slice([0, 0, 0, 5], [numCells, numCells, numBoxes, _this.config.classes.length]), 3) : tf.scalar(0);\n              return [boxes, scores, classScores];\n            }), boxesTensor = _a[0], scoresTensor = _a[1], classScoresTensor = _a[2];\n            results = [];\n            return [4 /*yield*/, scoresTensor.array()];\n          case 1:\n            scoresData = _d.sent();\n            return [4 /*yield*/, boxesTensor.array()];\n          case 2:\n            boxesData = _d.sent();\n            row = 0;\n            _d.label = 3;\n          case 3:\n            if (!(row < numCells)) return [3 /*break*/, 12];\n            col = 0;\n            _d.label = 4;\n          case 4:\n            if (!(col < numCells)) return [3 /*break*/, 11];\n            anchor = 0;\n            _d.label = 5;\n          case 5:\n            if (!(anchor < numBoxes)) return [3 /*break*/, 10];\n            score = (0, _ops.sigmoid)(scoresData[row][col][anchor][0]);\n            if (!(!scoreThreshold || score > scoreThreshold)) return [3 /*break*/, 9];\n            ctX = (col + (0, _ops.sigmoid)(boxesData[row][col][anchor][0])) / numCells * correctionFactorX;\n            ctY = (row + (0, _ops.sigmoid)(boxesData[row][col][anchor][1])) / numCells * correctionFactorY;\n            width_1 = Math.exp(boxesData[row][col][anchor][2]) * this.config.anchors[anchor].x / numCells * correctionFactorX;\n            height_1 = Math.exp(boxesData[row][col][anchor][3]) * this.config.anchors[anchor].y / numCells * correctionFactorY;\n            x = ctX - width_1 / 2;\n            y = ctY - height_1 / 2;\n            pos = { row: row, col: col, anchor: anchor };\n            if (!this.withClassScores) return [3 /*break*/, 7];\n            return [4 /*yield*/, this.extractPredictedClass(classScoresTensor, pos)];\n          case 6:\n            _c = _d.sent();\n            return [3 /*break*/, 8];\n          case 7:\n            _c = { classScore: 1, label: 0 };\n            _d.label = 8;\n          case 8:\n            _b = _c, classScore = _b.classScore, label = _b.label;\n            results.push((0, _tslib.__assign)({ box: new _BoundingBox.BoundingBox(x, y, x + width_1, y + height_1), score: score, classScore: score * classScore, label: label }, pos));\n            _d.label = 9;\n          case 9:\n            anchor++;\n            return [3 /*break*/, 5];\n          case 10:\n            col++;\n            return [3 /*break*/, 4];\n          case 11:\n            row++;\n            return [3 /*break*/, 3];\n          case 12:\n            boxesTensor.dispose();\n            scoresTensor.dispose();\n            classScoresTensor.dispose();\n            return [2 /*return*/, results];\n        }\n      });\n    });\n  };\n  TinyYolov2Base.prototype.extractPredictedClass = function (classesTensor, pos) {\n    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {\n      var row, col, anchor, classesData;\n      return (0, _tslib.__generator)(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            row = pos.row, col = pos.col, anchor = pos.anchor;\n            return [4 /*yield*/, classesTensor.array()];\n          case 1:\n            classesData = _a.sent();\n            return [2 /*return*/, Array(this.config.classes.length).fill(0).map(function (_, i) {\n              return classesData[row][col][anchor][i];\n            }).map(function (classScore, label) {\n              return {\n                classScore: classScore,\n                label: label\n              };\n            }).reduce(function (max, curr) {\n              return max.classScore > curr.classScore ? max : curr;\n            })];\n        }\n      });\n    });\n  };\n  TinyYolov2Base.DEFAULT_FILTER_SIZES = [3, 16, 32, 64, 128, 256, 512, 1024, 1024];\n  return TinyYolov2Base;\n}(_NeuralNetwork.NeuralNetwork);\nexports.TinyYolov2Base = TinyYolov2Base;\n//# sourceMappingURL=TinyYolov2Base.js.map"},"hash":"6e9561f0cae2ea925bf981a64e360aa3"}
{"dependencies":[{"name":"tslib","loc":{"line":1,"column":50}},{"name":"@tensorflow/tfjs-core","loc":{"line":2,"column":20}},{"name":"../classes","loc":{"line":3,"column":21}},{"name":"../classes/FaceDetection","loc":{"line":4,"column":30}},{"name":"../dom","loc":{"line":5,"column":27}},{"name":"../NeuralNetwork","loc":{"line":6,"column":30}},{"name":"./extractParams","loc":{"line":7,"column":30}},{"name":"./extractParamsFromWeigthMap","loc":{"line":8,"column":43}},{"name":"./mobileNetV1","loc":{"line":9,"column":28}},{"name":"./nonMaxSuppression","loc":{"line":10,"column":34}},{"name":"./outputLayer","loc":{"line":11,"column":28}},{"name":"./predictionLayer","loc":{"line":12,"column":32}},{"name":"./SsdMobilenetv1Options","loc":{"line":13,"column":38}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SsdMobilenetv1 = undefined;\n\nvar _tslib = require(\"tslib\");\n\nvar _tfjsCore = require(\"@tensorflow/tfjs-core\");\n\nvar tf = _interopRequireWildcard(_tfjsCore);\n\nvar _classes = require(\"../classes\");\n\nvar _FaceDetection = require(\"../classes/FaceDetection\");\n\nvar _dom = require(\"../dom\");\n\nvar _NeuralNetwork = require(\"../NeuralNetwork\");\n\nvar _extractParams = require(\"./extractParams\");\n\nvar _extractParamsFromWeigthMap = require(\"./extractParamsFromWeigthMap\");\n\nvar _mobileNetV = require(\"./mobileNetV1\");\n\nvar _nonMaxSuppression = require(\"./nonMaxSuppression\");\n\nvar _outputLayer = require(\"./outputLayer\");\n\nvar _predictionLayer = require(\"./predictionLayer\");\n\nvar _SsdMobilenetv1Options = require(\"./SsdMobilenetv1Options\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar SsdMobilenetv1 = /** @class */function (_super) {\n  (0, _tslib.__extends)(SsdMobilenetv1, _super);\n  function SsdMobilenetv1() {\n    return _super.call(this, 'SsdMobilenetv1') || this;\n  }\n  SsdMobilenetv1.prototype.forwardInput = function (input) {\n    var params = this.params;\n    if (!params) {\n      throw new Error('SsdMobilenetv1 - load model before inference');\n    }\n    return tf.tidy(function () {\n      var batchTensor = input.toBatchTensor(512, false).toFloat();\n      var x = tf.sub(tf.mul(batchTensor, tf.scalar(0.007843137718737125)), tf.scalar(1));\n      var features = (0, _mobileNetV.mobileNetV1)(x, params.mobilenetv1);\n      var _a = (0, _predictionLayer.predictionLayer)(features.out, features.conv11, params.prediction_layer),\n          boxPredictions = _a.boxPredictions,\n          classPredictions = _a.classPredictions;\n      return (0, _outputLayer.outputLayer)(boxPredictions, classPredictions, params.output_layer);\n    });\n  };\n  SsdMobilenetv1.prototype.forward = function (input) {\n    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {\n      var _a;\n      return (0, _tslib.__generator)(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = this.forwardInput;\n            return [4 /*yield*/, (0, _dom.toNetInput)(input)];\n          case 1:\n            return [2 /*return*/, _a.apply(this, [_b.sent()])];\n        }\n      });\n    });\n  };\n  SsdMobilenetv1.prototype.locateFaces = function (input, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {\n      var _a, maxResults, minConfidence, netInput, _b, _boxes, _scores, boxes, scores, i, scoresData, _c, _d, iouThreshold, indices, reshapedDims, inputSize, padX, padY, boxesData, results;\n      return (0, _tslib.__generator)(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            _a = new _SsdMobilenetv1Options.SsdMobilenetv1Options(options), maxResults = _a.maxResults, minConfidence = _a.minConfidence;\n            return [4 /*yield*/, (0, _dom.toNetInput)(input)];\n          case 1:\n            netInput = _e.sent();\n            _b = this.forwardInput(netInput), _boxes = _b.boxes, _scores = _b.scores;\n            boxes = _boxes[0];\n            scores = _scores[0];\n            for (i = 1; i < _boxes.length; i++) {\n              _boxes[i].dispose();\n              _scores[i].dispose();\n            }\n            _d = (_c = Array).from;\n            return [4 /*yield*/, scores.data()];\n          case 2:\n            scoresData = _d.apply(_c, [_e.sent()]);\n            iouThreshold = 0.5;\n            indices = (0, _nonMaxSuppression.nonMaxSuppression)(boxes, scoresData, maxResults, iouThreshold, minConfidence);\n            reshapedDims = netInput.getReshapedInputDimensions(0);\n            inputSize = netInput.inputSize;\n            padX = inputSize / reshapedDims.width;\n            padY = inputSize / reshapedDims.height;\n            boxesData = boxes.arraySync();\n            results = indices.map(function (idx) {\n              var _a = [Math.max(0, boxesData[idx][0]), Math.min(1.0, boxesData[idx][2])].map(function (val) {\n                return val * padY;\n              }),\n                  top = _a[0],\n                  bottom = _a[1];\n              var _b = [Math.max(0, boxesData[idx][1]), Math.min(1.0, boxesData[idx][3])].map(function (val) {\n                return val * padX;\n              }),\n                  left = _b[0],\n                  right = _b[1];\n              return new _FaceDetection.FaceDetection(scoresData[idx], new _classes.Rect(left, top, right - left, bottom - top), {\n                height: netInput.getInputHeight(0),\n                width: netInput.getInputWidth(0)\n              });\n            });\n            boxes.dispose();\n            scores.dispose();\n            return [2 /*return*/, results];\n        }\n      });\n    });\n  };\n  SsdMobilenetv1.prototype.getDefaultModelName = function () {\n    return 'ssd_mobilenetv1_model';\n  };\n  SsdMobilenetv1.prototype.extractParamsFromWeigthMap = function (weightMap) {\n    return (0, _extractParamsFromWeigthMap.extractParamsFromWeigthMap)(weightMap);\n  };\n  SsdMobilenetv1.prototype.extractParams = function (weights) {\n    return (0, _extractParams.extractParams)(weights);\n  };\n  return SsdMobilenetv1;\n}(_NeuralNetwork.NeuralNetwork);\nexports.SsdMobilenetv1 = SsdMobilenetv1;\n//# sourceMappingURL=SsdMobilenetv1.js.map"},"hash":"5a8bc10bb57a022fc40e9901115592b6"}
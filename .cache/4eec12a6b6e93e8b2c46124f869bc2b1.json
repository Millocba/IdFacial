{"dependencies":[{"name":"../ops","loc":{"line":1,"column":24}},{"name":"../utils","loc":{"line":2,"column":31}},{"name":"./Box","loc":{"line":3,"column":20}},{"name":"./Dimensions","loc":{"line":4,"column":27}},{"name":"./FaceDetection","loc":{"line":5,"column":30}},{"name":"./Point","loc":{"line":6,"column":22}},{"name":"./Rect","loc":{"line":7,"column":21}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FaceLandmarks = undefined;\n\nvar _ops = require(\"../ops\");\n\nvar _utils = require(\"../utils\");\n\nvar _Box = require(\"./Box\");\n\nvar _Dimensions = require(\"./Dimensions\");\n\nvar _FaceDetection = require(\"./FaceDetection\");\n\nvar _Point = require(\"./Point\");\n\nvar _Rect = require(\"./Rect\");\n\n// face alignment constants\nvar relX = 0.5;\nvar relY = 0.43;\nvar relScale = 0.45;\nvar FaceLandmarks = /** @class */function () {\n  function FaceLandmarks(relativeFaceLandmarkPositions, imgDims, shift) {\n    if (shift === void 0) {\n      shift = new _Point.Point(0, 0);\n    }\n    var width = imgDims.width,\n        height = imgDims.height;\n    this._imgDims = new _Dimensions.Dimensions(width, height);\n    this._shift = shift;\n    this._positions = relativeFaceLandmarkPositions.map(function (pt) {\n      return pt.mul(new _Point.Point(width, height)).add(shift);\n    });\n  }\n  Object.defineProperty(FaceLandmarks.prototype, \"shift\", {\n    get: function () {\n      return new _Point.Point(this._shift.x, this._shift.y);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FaceLandmarks.prototype, \"imageWidth\", {\n    get: function () {\n      return this._imgDims.width;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FaceLandmarks.prototype, \"imageHeight\", {\n    get: function () {\n      return this._imgDims.height;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FaceLandmarks.prototype, \"positions\", {\n    get: function () {\n      return this._positions;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FaceLandmarks.prototype, \"relativePositions\", {\n    get: function () {\n      var _this = this;\n      return this._positions.map(function (pt) {\n        return pt.sub(_this._shift).div(new _Point.Point(_this.imageWidth, _this.imageHeight));\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  FaceLandmarks.prototype.forSize = function (width, height) {\n    return new this.constructor(this.relativePositions, { width: width, height: height });\n  };\n  FaceLandmarks.prototype.shiftBy = function (x, y) {\n    return new this.constructor(this.relativePositions, this._imgDims, new _Point.Point(x, y));\n  };\n  FaceLandmarks.prototype.shiftByPoint = function (pt) {\n    return this.shiftBy(pt.x, pt.y);\n  };\n  /**\r\n   * Aligns the face landmarks after face detection from the relative positions of the faces\r\n   * bounding box, or it's current shift. This function should be used to align the face images\r\n   * after face detection has been performed, before they are passed to the face recognition net.\r\n   * This will make the computed face descriptor more accurate.\r\n   *\r\n   * @param detection (optional) The bounding box of the face or the face detection result. If\r\n   * no argument was passed the position of the face landmarks are assumed to be relative to\r\n   * it's current shift.\r\n   * @returns The bounding box of the aligned face.\r\n   */\n  FaceLandmarks.prototype.align = function (detection, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    if (detection) {\n      var box = detection instanceof _FaceDetection.FaceDetection ? detection.box.floor() : new _Box.Box(detection);\n      return this.shiftBy(box.x, box.y).align(null, options);\n    }\n    var _a = Object.assign({}, { useDlibAlignment: false, minBoxPadding: 0.2 }, options),\n        useDlibAlignment = _a.useDlibAlignment,\n        minBoxPadding = _a.minBoxPadding;\n    if (useDlibAlignment) {\n      return this.alignDlib();\n    }\n    return this.alignMinBbox(minBoxPadding);\n  };\n  FaceLandmarks.prototype.alignDlib = function () {\n    var centers = this.getRefPointsForAlignment();\n    var leftEyeCenter = centers[0],\n        rightEyeCenter = centers[1],\n        mouthCenter = centers[2];\n    var distToMouth = function (pt) {\n      return mouthCenter.sub(pt).magnitude();\n    };\n    var eyeToMouthDist = (distToMouth(leftEyeCenter) + distToMouth(rightEyeCenter)) / 2;\n    var size = Math.floor(eyeToMouthDist / relScale);\n    var refPoint = (0, _utils.getCenterPoint)(centers);\n    // TODO: pad in case rectangle is out of image bounds\n    var x = Math.floor(Math.max(0, refPoint.x - relX * size));\n    var y = Math.floor(Math.max(0, refPoint.y - relY * size));\n    return new _Rect.Rect(x, y, Math.min(size, this.imageWidth + x), Math.min(size, this.imageHeight + y));\n  };\n  FaceLandmarks.prototype.alignMinBbox = function (padding) {\n    var box = (0, _ops.minBbox)(this.positions);\n    return box.pad(box.width * padding, box.height * padding);\n  };\n  FaceLandmarks.prototype.getRefPointsForAlignment = function () {\n    throw new Error('getRefPointsForAlignment not implemented by base class');\n  };\n  return FaceLandmarks;\n}();\nexports.FaceLandmarks = FaceLandmarks;\n//# sourceMappingURL=FaceLandmarks.js.map"},"hash":"958711cd722d4fd0812881b0df87f6f1"}
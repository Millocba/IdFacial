{"dependencies":[{"name":"tslib","loc":{"line":1,"column":39}},{"name":"../utils","loc":{"line":2,"column":39}},{"name":"./awaitMediaLoaded","loc":{"line":3,"column":33}},{"name":"./isMediaElement","loc":{"line":4,"column":31}},{"name":"./NetInput","loc":{"line":5,"column":25}},{"name":"./resolveInput","loc":{"line":6,"column":29}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toNetInput = toNetInput;\n\nvar _tslib = require(\"tslib\");\n\nvar _utils = require(\"../utils\");\n\nvar _awaitMediaLoaded = require(\"./awaitMediaLoaded\");\n\nvar _isMediaElement = require(\"./isMediaElement\");\n\nvar _NetInput = require(\"./NetInput\");\n\nvar _resolveInput = require(\"./resolveInput\");\n\n/**\r\n * Validates the input to make sure, they are valid net inputs and awaits all media elements\r\n * to be finished loading.\r\n *\r\n * @param input The input, which can be a media element or an array of different media elements.\r\n * @returns A NetInput instance, which can be passed into one of the neural networks.\r\n */\nfunction toNetInput(inputs) {\n  return (0, _tslib.__awaiter)(this, void 0, void 0, function () {\n    var inputArgArray, getIdxHint, inputArray;\n    return (0, _tslib.__generator)(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (inputs instanceof _NetInput.NetInput) {\n            return [2 /*return*/, inputs];\n          }\n          inputArgArray = Array.isArray(inputs) ? inputs : [inputs];\n          if (!inputArgArray.length) {\n            throw new Error('toNetInput - empty array passed as input');\n          }\n          getIdxHint = function (idx) {\n            return Array.isArray(inputs) ? \" at input index \" + idx + \":\" : '';\n          };\n          inputArray = inputArgArray.map(_resolveInput.resolveInput);\n          inputArray.forEach(function (input, i) {\n            if (!(0, _isMediaElement.isMediaElement)(input) && !(0, _utils.isTensor3D)(input) && !(0, _utils.isTensor4D)(input)) {\n              if (typeof inputArgArray[i] === 'string') {\n                throw new Error(\"toNetInput -\" + getIdxHint(i) + \" string passed, but could not resolve HTMLElement for element id \" + inputArgArray[i]);\n              }\n              throw new Error(\"toNetInput -\" + getIdxHint(i) + \" expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id\");\n            }\n            if ((0, _utils.isTensor4D)(input)) {\n              // if tf.Tensor4D is passed in the input array, the batch size has to be 1\n              var batchSize = input.shape[0];\n              if (batchSize !== 1) {\n                throw new Error(\"toNetInput -\" + getIdxHint(i) + \" tf.Tensor4D with batchSize \" + batchSize + \" passed, but not supported in input array\");\n              }\n            }\n          });\n          // wait for all media elements being loaded\n          return [4 /*yield*/, Promise.all(inputArray.map(function (input) {\n            return (0, _isMediaElement.isMediaElement)(input) && (0, _awaitMediaLoaded.awaitMediaLoaded)(input);\n          }))];\n        case 1:\n          // wait for all media elements being loaded\n          _a.sent();\n          return [2 /*return*/, new _NetInput.NetInput(inputArray, Array.isArray(inputs))];\n      }\n    });\n  });\n}\n//# sourceMappingURL=toNetInput.js.map"},"hash":"44af63842e186f85738eb97b3d062d32"}
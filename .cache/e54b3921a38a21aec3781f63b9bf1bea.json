{"dependencies":[{"name":"@tensorflow/tfjs-core","loc":{"line":1,"column":20}},{"name":"../env","loc":{"line":2,"column":20}},{"name":"../ops/padToSquare","loc":{"line":3,"column":28}},{"name":"../utils","loc":{"line":4,"column":73}},{"name":"./createCanvas","loc":{"line":5,"column":38}},{"name":"./imageToSquare","loc":{"line":6,"column":30}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NetInput = undefined;\n\nvar _tfjsCore = require(\"@tensorflow/tfjs-core\");\n\nvar tf = _interopRequireWildcard(_tfjsCore);\n\nvar _env = require(\"../env\");\n\nvar _padToSquare = require(\"../ops/padToSquare\");\n\nvar _utils = require(\"../utils\");\n\nvar _createCanvas = require(\"./createCanvas\");\n\nvar _imageToSquare = require(\"./imageToSquare\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar NetInput = /** @class */function () {\n  function NetInput(inputs, treatAsBatchInput) {\n    var _this = this;\n    if (treatAsBatchInput === void 0) {\n      treatAsBatchInput = false;\n    }\n    this._imageTensors = [];\n    this._canvases = [];\n    this._treatAsBatchInput = false;\n    this._inputDimensions = [];\n    if (!Array.isArray(inputs)) {\n      throw new Error(\"NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have \" + inputs);\n    }\n    this._treatAsBatchInput = treatAsBatchInput;\n    this._batchSize = inputs.length;\n    inputs.forEach(function (input, idx) {\n      if ((0, _utils.isTensor3D)(input)) {\n        _this._imageTensors[idx] = input;\n        _this._inputDimensions[idx] = input.shape;\n        return;\n      }\n      if ((0, _utils.isTensor4D)(input)) {\n        var batchSize = input.shape[0];\n        if (batchSize !== 1) {\n          throw new Error(\"NetInput - tf.Tensor4D with batchSize \" + batchSize + \" passed, but not supported in input array\");\n        }\n        _this._imageTensors[idx] = input;\n        _this._inputDimensions[idx] = input.shape.slice(1);\n        return;\n      }\n      var canvas = input instanceof _env.env.getEnv().Canvas ? input : (0, _createCanvas.createCanvasFromMedia)(input);\n      _this._canvases[idx] = canvas;\n      _this._inputDimensions[idx] = [canvas.height, canvas.width, 3];\n    });\n  }\n  Object.defineProperty(NetInput.prototype, \"imageTensors\", {\n    get: function () {\n      return this._imageTensors;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NetInput.prototype, \"canvases\", {\n    get: function () {\n      return this._canvases;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NetInput.prototype, \"isBatchInput\", {\n    get: function () {\n      return this.batchSize > 1 || this._treatAsBatchInput;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NetInput.prototype, \"batchSize\", {\n    get: function () {\n      return this._batchSize;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NetInput.prototype, \"inputDimensions\", {\n    get: function () {\n      return this._inputDimensions;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NetInput.prototype, \"inputSize\", {\n    get: function () {\n      return this._inputSize;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NetInput.prototype, \"reshapedInputDimensions\", {\n    get: function () {\n      var _this = this;\n      return (0, _utils.range)(this.batchSize, 0, 1).map(function (_, batchIdx) {\n        return _this.getReshapedInputDimensions(batchIdx);\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  NetInput.prototype.getInput = function (batchIdx) {\n    return this.canvases[batchIdx] || this.imageTensors[batchIdx];\n  };\n  NetInput.prototype.getInputDimensions = function (batchIdx) {\n    return this._inputDimensions[batchIdx];\n  };\n  NetInput.prototype.getInputHeight = function (batchIdx) {\n    return this._inputDimensions[batchIdx][0];\n  };\n  NetInput.prototype.getInputWidth = function (batchIdx) {\n    return this._inputDimensions[batchIdx][1];\n  };\n  NetInput.prototype.getReshapedInputDimensions = function (batchIdx) {\n    if (typeof this.inputSize !== 'number') {\n      throw new Error('getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet');\n    }\n    var width = this.getInputWidth(batchIdx);\n    var height = this.getInputHeight(batchIdx);\n    return (0, _utils.computeReshapedDimensions)({ width: width, height: height }, this.inputSize);\n  };\n  /**\r\n   * Create a batch tensor from all input canvases and tensors\r\n   * with size [batchSize, inputSize, inputSize, 3].\r\n   *\r\n   * @param inputSize Height and width of the tensor.\r\n   * @param isCenterImage (optional, default: false) If true, add an equal amount of padding on\r\n   * both sides of the minor dimension oof the image.\r\n   * @returns The batch tensor.\r\n   */\n  NetInput.prototype.toBatchTensor = function (inputSize, isCenterInputs) {\n    var _this = this;\n    if (isCenterInputs === void 0) {\n      isCenterInputs = true;\n    }\n    this._inputSize = inputSize;\n    return tf.tidy(function () {\n      var inputTensors = (0, _utils.range)(_this.batchSize, 0, 1).map(function (batchIdx) {\n        var input = _this.getInput(batchIdx);\n        if (input instanceof tf.Tensor) {\n          var imgTensor = (0, _utils.isTensor4D)(input) ? input : input.expandDims();\n          imgTensor = (0, _padToSquare.padToSquare)(imgTensor, isCenterInputs);\n          if (imgTensor.shape[1] !== inputSize || imgTensor.shape[2] !== inputSize) {\n            imgTensor = tf.image.resizeBilinear(imgTensor, [inputSize, inputSize]);\n          }\n          return imgTensor.as3D(inputSize, inputSize, 3);\n        }\n        if (input instanceof _env.env.getEnv().Canvas) {\n          return tf.browser.fromPixels((0, _imageToSquare.imageToSquare)(input, inputSize, isCenterInputs));\n        }\n        throw new Error(\"toBatchTensor - at batchIdx \" + batchIdx + \", expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have \" + input);\n      });\n      var batchTensor = tf.stack(inputTensors.map(function (t) {\n        return t.toFloat();\n      })).as4D(_this.batchSize, inputSize, inputSize, 3);\n      return batchTensor;\n    });\n  };\n  return NetInput;\n}();\nexports.NetInput = NetInput;\n//# sourceMappingURL=NetInput.js.map"},"hash":"391ad336f3083778e6ad9a5353d80222"}
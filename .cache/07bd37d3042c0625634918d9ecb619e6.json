{"dependencies":[{"name":"tslib","loc":{"line":1,"column":50}},{"name":"@tensorflow/tfjs-core","loc":{"line":2,"column":20}},{"name":"../dom","loc":{"line":3,"column":27}},{"name":"../NeuralNetwork","loc":{"line":4,"column":30}},{"name":"../ops","loc":{"line":5,"column":26}},{"name":"./convLayer","loc":{"line":6,"column":25}},{"name":"./extractParams","loc":{"line":7,"column":30}},{"name":"./extractParamsFromWeigthMap","loc":{"line":8,"column":43}},{"name":"./residualLayer","loc":{"line":9,"column":39}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FaceRecognitionNet = undefined;\n\nvar _tslib = require(\"tslib\");\n\nvar _tfjsCore = require(\"@tensorflow/tfjs-core\");\n\nvar tf = _interopRequireWildcard(_tfjsCore);\n\nvar _dom = require(\"../dom\");\n\nvar _NeuralNetwork = require(\"../NeuralNetwork\");\n\nvar _ops = require(\"../ops\");\n\nvar _convLayer = require(\"./convLayer\");\n\nvar _extractParams = require(\"./extractParams\");\n\nvar _extractParamsFromWeigthMap = require(\"./extractParamsFromWeigthMap\");\n\nvar _residualLayer = require(\"./residualLayer\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar FaceRecognitionNet = /** @class */function (_super) {\n  (0, _tslib.__extends)(FaceRecognitionNet, _super);\n  function FaceRecognitionNet() {\n    return _super.call(this, 'FaceRecognitionNet') || this;\n  }\n  FaceRecognitionNet.prototype.forwardInput = function (input) {\n    var params = this.params;\n    if (!params) {\n      throw new Error('FaceRecognitionNet - load model before inference');\n    }\n    return tf.tidy(function () {\n      var batchTensor = input.toBatchTensor(150, true).toFloat();\n      var meanRgb = [122.782, 117.001, 104.298];\n      var normalized = (0, _ops.normalize)(batchTensor, meanRgb).div(tf.scalar(256));\n      var out = (0, _convLayer.convDown)(normalized, params.conv32_down);\n      out = tf.maxPool(out, 3, 2, 'valid');\n      out = (0, _residualLayer.residual)(out, params.conv32_1);\n      out = (0, _residualLayer.residual)(out, params.conv32_2);\n      out = (0, _residualLayer.residual)(out, params.conv32_3);\n      out = (0, _residualLayer.residualDown)(out, params.conv64_down);\n      out = (0, _residualLayer.residual)(out, params.conv64_1);\n      out = (0, _residualLayer.residual)(out, params.conv64_2);\n      out = (0, _residualLayer.residual)(out, params.conv64_3);\n      out = (0, _residualLayer.residualDown)(out, params.conv128_down);\n      out = (0, _residualLayer.residual)(out, params.conv128_1);\n      out = (0, _residualLayer.residual)(out, params.conv128_2);\n      out = (0, _residualLayer.residualDown)(out, params.conv256_down);\n      out = (0, _residualLayer.residual)(out, params.conv256_1);\n      out = (0, _residualLayer.residual)(out, params.conv256_2);\n      out = (0, _residualLayer.residualDown)(out, params.conv256_down_out);\n      var globalAvg = out.mean([1, 2]);\n      var fullyConnected = tf.matMul(globalAvg, params.fc);\n      return fullyConnected;\n    });\n  };\n  FaceRecognitionNet.prototype.forward = function (input) {\n    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {\n      var _a;\n      return (0, _tslib.__generator)(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = this.forwardInput;\n            return [4 /*yield*/, (0, _dom.toNetInput)(input)];\n          case 1:\n            return [2 /*return*/, _a.apply(this, [_b.sent()])];\n        }\n      });\n    });\n  };\n  FaceRecognitionNet.prototype.computeFaceDescriptor = function (input) {\n    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {\n      var netInput, faceDescriptorTensors, faceDescriptorsForBatch;\n      var _this = this;\n      return (0, _tslib.__generator)(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, (0, _dom.toNetInput)(input)];\n          case 1:\n            netInput = _a.sent();\n            faceDescriptorTensors = tf.tidy(function () {\n              return tf.unstack(_this.forwardInput(netInput));\n            });\n            return [4 /*yield*/, Promise.all(faceDescriptorTensors.map(function (t) {\n              return t.data();\n            }))];\n          case 2:\n            faceDescriptorsForBatch = _a.sent();\n            faceDescriptorTensors.forEach(function (t) {\n              return t.dispose();\n            });\n            return [2 /*return*/, netInput.isBatchInput ? faceDescriptorsForBatch : faceDescriptorsForBatch[0]];\n        }\n      });\n    });\n  };\n  FaceRecognitionNet.prototype.getDefaultModelName = function () {\n    return 'face_recognition_model';\n  };\n  FaceRecognitionNet.prototype.extractParamsFromWeigthMap = function (weightMap) {\n    return (0, _extractParamsFromWeigthMap.extractParamsFromWeigthMap)(weightMap);\n  };\n  FaceRecognitionNet.prototype.extractParams = function (weights) {\n    return (0, _extractParams.extractParams)(weights);\n  };\n  return FaceRecognitionNet;\n}(_NeuralNetwork.NeuralNetwork);\nexports.FaceRecognitionNet = FaceRecognitionNet;\n//# sourceMappingURL=FaceRecognitionNet.js.map"},"hash":"ed940b566dea8348432ad3022a0387c1"}
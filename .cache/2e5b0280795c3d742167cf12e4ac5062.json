{"dependencies":[{"name":"tslib","loc":{"line":1,"column":50}},{"name":"@tensorflow/tfjs-core","loc":{"line":2,"column":20}},{"name":"../dom","loc":{"line":3,"column":49}},{"name":"../factories/WithFaceLandmarks","loc":{"line":4,"column":40}},{"name":"./ComposableTask","loc":{"line":5,"column":31}},{"name":"./ComputeFaceDescriptorsTasks","loc":{"line":6,"column":79}},{"name":"./nets","loc":{"line":7,"column":21}},{"name":"./PredictAgeAndGenderTask","loc":{"line":8,"column":109}},{"name":"./PredictFaceExpressionsTask","loc":{"line":9,"column":115}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DetectSingleFaceLandmarksTask = exports.DetectAllFaceLandmarksTask = exports.DetectFaceLandmarksTaskBase = undefined;\n\nvar _tslib = require(\"tslib\");\n\nvar _tfjsCore = require(\"@tensorflow/tfjs-core\");\n\nvar tf = _interopRequireWildcard(_tfjsCore);\n\nvar _dom = require(\"../dom\");\n\nvar _WithFaceLandmarks = require(\"../factories/WithFaceLandmarks\");\n\nvar _ComposableTask = require(\"./ComposableTask\");\n\nvar _ComputeFaceDescriptorsTasks = require(\"./ComputeFaceDescriptorsTasks\");\n\nvar _nets = require(\"./nets\");\n\nvar _PredictAgeAndGenderTask = require(\"./PredictAgeAndGenderTask\");\n\nvar _PredictFaceExpressionsTask = require(\"./PredictFaceExpressionsTask\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar DetectFaceLandmarksTaskBase = /** @class */function (_super) {\n  (0, _tslib.__extends)(DetectFaceLandmarksTaskBase, _super);\n  function DetectFaceLandmarksTaskBase(parentTask, input, useTinyLandmarkNet) {\n    var _this = _super.call(this) || this;\n    _this.parentTask = parentTask;\n    _this.input = input;\n    _this.useTinyLandmarkNet = useTinyLandmarkNet;\n    return _this;\n  }\n  Object.defineProperty(DetectFaceLandmarksTaskBase.prototype, \"landmarkNet\", {\n    get: function () {\n      return this.useTinyLandmarkNet ? _nets.nets.faceLandmark68TinyNet : _nets.nets.faceLandmark68Net;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return DetectFaceLandmarksTaskBase;\n}(_ComposableTask.ComposableTask);\nexports.DetectFaceLandmarksTaskBase = DetectFaceLandmarksTaskBase;\n\nvar DetectAllFaceLandmarksTask = /** @class */function (_super) {\n  (0, _tslib.__extends)(DetectAllFaceLandmarksTask, _super);\n  function DetectAllFaceLandmarksTask() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  DetectAllFaceLandmarksTask.prototype.run = function () {\n    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {\n      var parentResults, detections, faces, _a, faceLandmarksByFace;\n      var _this = this;\n      return (0, _tslib.__generator)(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4 /*yield*/, this.parentTask];\n          case 1:\n            parentResults = _b.sent();\n            detections = parentResults.map(function (res) {\n              return res.detection;\n            });\n            if (!(this.input instanceof tf.Tensor)) return [3 /*break*/, 3];\n            return [4 /*yield*/, (0, _dom.extractFaceTensors)(this.input, detections)];\n          case 2:\n            _a = _b.sent();\n            return [3 /*break*/, 5];\n          case 3:\n            return [4 /*yield*/, (0, _dom.extractFaces)(this.input, detections)];\n          case 4:\n            _a = _b.sent();\n            _b.label = 5;\n          case 5:\n            faces = _a;\n            return [4 /*yield*/, Promise.all(faces.map(function (face) {\n              return _this.landmarkNet.detectLandmarks(face);\n            }))];\n          case 6:\n            faceLandmarksByFace = _b.sent();\n            faces.forEach(function (f) {\n              return f instanceof tf.Tensor && f.dispose();\n            });\n            return [2 /*return*/, parentResults.map(function (parentResult, i) {\n              return (0, _WithFaceLandmarks.extendWithFaceLandmarks)(parentResult, faceLandmarksByFace[i]);\n            })];\n        }\n      });\n    });\n  };\n  DetectAllFaceLandmarksTask.prototype.withFaceExpressions = function () {\n    return new _PredictFaceExpressionsTask.PredictAllFaceExpressionsWithFaceAlignmentTask(this, this.input);\n  };\n  DetectAllFaceLandmarksTask.prototype.withAgeAndGender = function () {\n    return new _PredictAgeAndGenderTask.PredictAllAgeAndGenderWithFaceAlignmentTask(this, this.input);\n  };\n  DetectAllFaceLandmarksTask.prototype.withFaceDescriptors = function () {\n    return new _ComputeFaceDescriptorsTasks.ComputeAllFaceDescriptorsTask(this, this.input);\n  };\n  return DetectAllFaceLandmarksTask;\n}(DetectFaceLandmarksTaskBase);\nexports.DetectAllFaceLandmarksTask = DetectAllFaceLandmarksTask;\n\nvar DetectSingleFaceLandmarksTask = /** @class */function (_super) {\n  (0, _tslib.__extends)(DetectSingleFaceLandmarksTask, _super);\n  function DetectSingleFaceLandmarksTask() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  DetectSingleFaceLandmarksTask.prototype.run = function () {\n    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {\n      var parentResult, detection, faces, _a, landmarks;\n      return (0, _tslib.__generator)(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4 /*yield*/, this.parentTask];\n          case 1:\n            parentResult = _b.sent();\n            if (!parentResult) {\n              return [2 /*return*/];\n            }\n            detection = parentResult.detection;\n            if (!(this.input instanceof tf.Tensor)) return [3 /*break*/, 3];\n            return [4 /*yield*/, (0, _dom.extractFaceTensors)(this.input, [detection])];\n          case 2:\n            _a = _b.sent();\n            return [3 /*break*/, 5];\n          case 3:\n            return [4 /*yield*/, (0, _dom.extractFaces)(this.input, [detection])];\n          case 4:\n            _a = _b.sent();\n            _b.label = 5;\n          case 5:\n            faces = _a;\n            return [4 /*yield*/, this.landmarkNet.detectLandmarks(faces[0])];\n          case 6:\n            landmarks = _b.sent();\n            faces.forEach(function (f) {\n              return f instanceof tf.Tensor && f.dispose();\n            });\n            return [2 /*return*/, (0, _WithFaceLandmarks.extendWithFaceLandmarks)(parentResult, landmarks)];\n        }\n      });\n    });\n  };\n  DetectSingleFaceLandmarksTask.prototype.withFaceExpressions = function () {\n    return new _PredictFaceExpressionsTask.PredictSingleFaceExpressionsWithFaceAlignmentTask(this, this.input);\n  };\n  DetectSingleFaceLandmarksTask.prototype.withAgeAndGender = function () {\n    return new _PredictAgeAndGenderTask.PredictSingleAgeAndGenderWithFaceAlignmentTask(this, this.input);\n  };\n  DetectSingleFaceLandmarksTask.prototype.withFaceDescriptor = function () {\n    return new _ComputeFaceDescriptorsTasks.ComputeSingleFaceDescriptorTask(this, this.input);\n  };\n  return DetectSingleFaceLandmarksTask;\n}(DetectFaceLandmarksTaskBase);\nexports.DetectSingleFaceLandmarksTask = DetectSingleFaceLandmarksTask;\n//# sourceMappingURL=DetectFaceLandmarksTasks.js.map"},"hash":"296f99ec3e2aa6e670af4222067d9e70"}
{"dependencies":[{"name":"../classes/FaceMatch","loc":{"line":1,"column":26}},{"name":"../classes/LabeledFaceDescriptors","loc":{"line":2,"column":39}},{"name":"../euclideanDistance","loc":{"line":3,"column":34}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FaceMatcher = undefined;\n\nvar _FaceMatch = require(\"../classes/FaceMatch\");\n\nvar _LabeledFaceDescriptors = require(\"../classes/LabeledFaceDescriptors\");\n\nvar _euclideanDistance = require(\"../euclideanDistance\");\n\nvar FaceMatcher = /** @class */function () {\n  function FaceMatcher(inputs, distanceThreshold) {\n    if (distanceThreshold === void 0) {\n      distanceThreshold = 0.6;\n    }\n    this._distanceThreshold = distanceThreshold;\n    var inputArray = Array.isArray(inputs) ? inputs : [inputs];\n    if (!inputArray.length) {\n      throw new Error(\"FaceRecognizer.constructor - expected atleast one input\");\n    }\n    var count = 1;\n    var createUniqueLabel = function () {\n      return \"person \" + count++;\n    };\n    this._labeledDescriptors = inputArray.map(function (desc) {\n      if (desc instanceof _LabeledFaceDescriptors.LabeledFaceDescriptors) {\n        return desc;\n      }\n      if (desc instanceof Float32Array) {\n        return new _LabeledFaceDescriptors.LabeledFaceDescriptors(createUniqueLabel(), [desc]);\n      }\n      if (desc.descriptor && desc.descriptor instanceof Float32Array) {\n        return new _LabeledFaceDescriptors.LabeledFaceDescriptors(createUniqueLabel(), [desc.descriptor]);\n      }\n      throw new Error(\"FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>\");\n    });\n  }\n  Object.defineProperty(FaceMatcher.prototype, \"labeledDescriptors\", {\n    get: function () {\n      return this._labeledDescriptors;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FaceMatcher.prototype, \"distanceThreshold\", {\n    get: function () {\n      return this._distanceThreshold;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  FaceMatcher.prototype.computeMeanDistance = function (queryDescriptor, descriptors) {\n    return descriptors.map(function (d) {\n      return (0, _euclideanDistance.euclideanDistance)(d, queryDescriptor);\n    }).reduce(function (d1, d2) {\n      return d1 + d2;\n    }, 0) / (descriptors.length || 1);\n  };\n  FaceMatcher.prototype.matchDescriptor = function (queryDescriptor) {\n    var _this = this;\n    return this.labeledDescriptors.map(function (_a) {\n      var descriptors = _a.descriptors,\n          label = _a.label;\n      return new _FaceMatch.FaceMatch(label, _this.computeMeanDistance(queryDescriptor, descriptors));\n    }).reduce(function (best, curr) {\n      return best.distance < curr.distance ? best : curr;\n    });\n  };\n  FaceMatcher.prototype.findBestMatch = function (queryDescriptor) {\n    var bestMatch = this.matchDescriptor(queryDescriptor);\n    return bestMatch.distance < this.distanceThreshold ? bestMatch : new _FaceMatch.FaceMatch('unknown', bestMatch.distance);\n  };\n  FaceMatcher.prototype.toJSON = function () {\n    return {\n      distanceThreshold: this.distanceThreshold,\n      labeledDescriptors: this.labeledDescriptors.map(function (ld) {\n        return ld.toJSON();\n      })\n    };\n  };\n  FaceMatcher.fromJSON = function (json) {\n    var labeledDescriptors = json.labeledDescriptors.map(function (ld) {\n      return _LabeledFaceDescriptors.LabeledFaceDescriptors.fromJSON(ld);\n    });\n    return new FaceMatcher(labeledDescriptors, json.distanceThreshold);\n  };\n  return FaceMatcher;\n}();\nexports.FaceMatcher = FaceMatcher;\n//# sourceMappingURL=FaceMatcher.js.map"},"hash":"1e75b4974a3c6de125f8957154fdf0bf"}
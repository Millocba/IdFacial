{"dependencies":[{"name":"tslib","loc":{"line":1,"column":50}},{"name":"@tensorflow/tfjs-core","loc":{"line":2,"column":20}},{"name":"../classes","loc":{"line":3,"column":28}},{"name":"../classes/FaceDetection","loc":{"line":4,"column":30}},{"name":"../classes/FaceLandmarks5","loc":{"line":5,"column":31}},{"name":"../dom","loc":{"line":6,"column":27}},{"name":"../factories","loc":{"line":7,"column":65}},{"name":"../NeuralNetwork","loc":{"line":8,"column":30}},{"name":"./bgrToRgbTensor","loc":{"line":9,"column":31}},{"name":"./config","loc":{"line":10,"column":26}},{"name":"./extractParams","loc":{"line":11,"column":30}},{"name":"./extractParamsFromWeigthMap","loc":{"line":12,"column":43}},{"name":"./getSizesForScale","loc":{"line":13,"column":33}},{"name":"./MtcnnOptions","loc":{"line":14,"column":29}},{"name":"./pyramidDown","loc":{"line":15,"column":28}},{"name":"./stage1","loc":{"line":16,"column":23}},{"name":"./stage2","loc":{"line":17,"column":23}},{"name":"./stage3","loc":{"line":18,"column":23}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Mtcnn = undefined;\n\nvar _tslib = require(\"tslib\");\n\nvar _tfjsCore = require(\"@tensorflow/tfjs-core\");\n\nvar tf = _interopRequireWildcard(_tfjsCore);\n\nvar _classes = require(\"../classes\");\n\nvar _FaceDetection = require(\"../classes/FaceDetection\");\n\nvar _FaceLandmarks = require(\"../classes/FaceLandmarks5\");\n\nvar _dom = require(\"../dom\");\n\nvar _factories = require(\"../factories\");\n\nvar _NeuralNetwork = require(\"../NeuralNetwork\");\n\nvar _bgrToRgbTensor = require(\"./bgrToRgbTensor\");\n\nvar _config = require(\"./config\");\n\nvar _extractParams = require(\"./extractParams\");\n\nvar _extractParamsFromWeigthMap = require(\"./extractParamsFromWeigthMap\");\n\nvar _getSizesForScale = require(\"./getSizesForScale\");\n\nvar _MtcnnOptions = require(\"./MtcnnOptions\");\n\nvar _pyramidDown = require(\"./pyramidDown\");\n\nvar _stage = require(\"./stage1\");\n\nvar _stage2 = require(\"./stage2\");\n\nvar _stage3 = require(\"./stage3\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar Mtcnn = /** @class */function (_super) {\n  (0, _tslib.__extends)(Mtcnn, _super);\n  function Mtcnn() {\n    return _super.call(this, 'Mtcnn') || this;\n  }\n  Mtcnn.prototype.load = function (weightsOrUrl) {\n    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {\n      return (0, _tslib.__generator)(this, function (_a) {\n        console.warn('mtcnn is deprecated and will be removed soon');\n        return [2 /*return*/, _super.prototype.load.call(this, weightsOrUrl)];\n      });\n    });\n  };\n  Mtcnn.prototype.loadFromDisk = function (filePath) {\n    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {\n      return (0, _tslib.__generator)(this, function (_a) {\n        console.warn('mtcnn is deprecated and will be removed soon');\n        return [2 /*return*/, _super.prototype.loadFromDisk.call(this, filePath)];\n      });\n    });\n  };\n  Mtcnn.prototype.forwardInput = function (input, forwardParams) {\n    if (forwardParams === void 0) {\n      forwardParams = {};\n    }\n    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {\n      var params, inputCanvas, stats, tsTotal, imgTensor, onReturn, _a, height, width, _b, minFaceSize, scaleFactor, maxNumScales, scoreThresholds, scaleSteps, scales, ts, out1, out2, out3, results;\n      return (0, _tslib.__generator)(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            params = this.params;\n            if (!params) {\n              throw new Error('Mtcnn - load model before inference');\n            }\n            inputCanvas = input.canvases[0];\n            if (!inputCanvas) {\n              throw new Error('Mtcnn - inputCanvas is not defined, note that passing tensors into Mtcnn.forwardInput is not supported yet.');\n            }\n            stats = {};\n            tsTotal = Date.now();\n            imgTensor = tf.tidy(function () {\n              return (0, _bgrToRgbTensor.bgrToRgbTensor)(tf.expandDims(tf.browser.fromPixels(inputCanvas)).toFloat());\n            });\n            onReturn = function (results) {\n              // dispose tensors on return\n              imgTensor.dispose();\n              stats.total = Date.now() - tsTotal;\n              return results;\n            };\n            _a = imgTensor.shape.slice(1), height = _a[0], width = _a[1];\n            _b = new _MtcnnOptions.MtcnnOptions(forwardParams), minFaceSize = _b.minFaceSize, scaleFactor = _b.scaleFactor, maxNumScales = _b.maxNumScales, scoreThresholds = _b.scoreThresholds, scaleSteps = _b.scaleSteps;\n            scales = (scaleSteps || (0, _pyramidDown.pyramidDown)(minFaceSize, scaleFactor, [height, width])).filter(function (scale) {\n              var sizes = (0, _getSizesForScale.getSizesForScale)(scale, [height, width]);\n              return Math.min(sizes.width, sizes.height) > _config.CELL_SIZE;\n            }).slice(0, maxNumScales);\n            stats.scales = scales;\n            stats.pyramid = scales.map(function (scale) {\n              return (0, _getSizesForScale.getSizesForScale)(scale, [height, width]);\n            });\n            ts = Date.now();\n            return [4 /*yield*/, (0, _stage.stage1)(imgTensor, scales, scoreThresholds[0], params.pnet, stats)];\n          case 1:\n            out1 = _c.sent();\n            stats.total_stage1 = Date.now() - ts;\n            if (!out1.boxes.length) {\n              return [2 /*return*/, onReturn({ results: [], stats: stats })];\n            }\n            stats.stage2_numInputBoxes = out1.boxes.length;\n            // using the inputCanvas to extract and resize the image patches, since it is faster\n            // than doing this on the gpu\n            ts = Date.now();\n            return [4 /*yield*/, (0, _stage2.stage2)(inputCanvas, out1.boxes, scoreThresholds[1], params.rnet, stats)];\n          case 2:\n            out2 = _c.sent();\n            stats.total_stage2 = Date.now() - ts;\n            if (!out2.boxes.length) {\n              return [2 /*return*/, onReturn({ results: [], stats: stats })];\n            }\n            stats.stage3_numInputBoxes = out2.boxes.length;\n            ts = Date.now();\n            return [4 /*yield*/, (0, _stage3.stage3)(inputCanvas, out2.boxes, scoreThresholds[2], params.onet, stats)];\n          case 3:\n            out3 = _c.sent();\n            stats.total_stage3 = Date.now() - ts;\n            results = out3.boxes.map(function (box, idx) {\n              return (0, _factories.extendWithFaceLandmarks)((0, _factories.extendWithFaceDetection)({}, new _FaceDetection.FaceDetection(out3.scores[idx], new _classes.Rect(box.left / width, box.top / height, box.width / width, box.height / height), {\n                height: height,\n                width: width\n              })), new _FaceLandmarks.FaceLandmarks5(out3.points[idx].map(function (pt) {\n                return pt.sub(new _classes.Point(box.left, box.top)).div(new _classes.Point(box.width, box.height));\n              }), { width: box.width, height: box.height }));\n            });\n            return [2 /*return*/, onReturn({ results: results, stats: stats })];\n        }\n      });\n    });\n  };\n  Mtcnn.prototype.forward = function (input, forwardParams) {\n    if (forwardParams === void 0) {\n      forwardParams = {};\n    }\n    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {\n      var _a;\n      return (0, _tslib.__generator)(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = this.forwardInput;\n            return [4 /*yield*/, (0, _dom.toNetInput)(input)];\n          case 1:\n            return [4 /*yield*/, _a.apply(this, [_b.sent(), forwardParams])];\n          case 2:\n            return [2 /*return*/, _b.sent().results];\n        }\n      });\n    });\n  };\n  Mtcnn.prototype.forwardWithStats = function (input, forwardParams) {\n    if (forwardParams === void 0) {\n      forwardParams = {};\n    }\n    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {\n      var _a;\n      return (0, _tslib.__generator)(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = this.forwardInput;\n            return [4 /*yield*/, (0, _dom.toNetInput)(input)];\n          case 1:\n            return [2 /*return*/, _a.apply(this, [_b.sent(), forwardParams])];\n        }\n      });\n    });\n  };\n  Mtcnn.prototype.getDefaultModelName = function () {\n    return 'mtcnn_model';\n  };\n  Mtcnn.prototype.extractParamsFromWeigthMap = function (weightMap) {\n    return (0, _extractParamsFromWeigthMap.extractParamsFromWeigthMap)(weightMap);\n  };\n  Mtcnn.prototype.extractParams = function (weights) {\n    return (0, _extractParams.extractParams)(weights);\n  };\n  return Mtcnn;\n}(_NeuralNetwork.NeuralNetwork);\nexports.Mtcnn = Mtcnn;\n//# sourceMappingURL=Mtcnn.js.map"},"hash":"d9064d3d4a9a0a35ea7c2268bc6f1774"}